#!/usr/bin/env pythonimport rospy, tfimport mathfrom std_msgs.msg import Stringfrom geometry_msgs.msg import Twistfrom kobuki_msgs.msg import BumperEventfrom nav_msgs.msg import Odometryfrom geometry_msgs.msg import PoseStampedfrom geometry_msgs.msg import Posefrom tf.transformations import euler_from_quaternion# Add additional imports for each of the message types used#drive to a goal subscribed as /move_base_simple/goaldef navToPose(goal):	global pose	print 'Start'	#get goal pose	p = goal.pose	goal_p = p.position	goal_q = p.orientation	#compute angle from current to goal	ang = math.atan2((float(goal_p.y)-pose.position.y ),(float(goal_p.x)-pose.position.x) )	print "spin!"	rotate(-(pose.orientation.z-ang))	#get goal distance	x1 = (goal_p.x - pose.position.x)	y1 = (goal_p.y-pose.position.y)	g_dist = math.sqrt(x1*x1 + y1*y1 )	print "move!"	driveStraight(0.5,g_dist)	#make final rotation	print "spin!"	rotate(-ang +goal_q.z)	print(goal_q.z)	print "done"#This function sequentially calls methods to perform a trajectory.def executeTrajectory():	driveStraight(.25,.6)	rotate(math.radians(90))	driveStraight(.25,.45)	rotate(math.radians(-135))#This function accepts two wheel velocities and a time interval.# assume u1 is left, u2 is right wheelsdef spinWheels(u1, u2, time):	#publisher data	global pub	twist = Twist()	now = rospy.Time().now().secs	#l is wheelbase	l = .23	#compute twist based on kinematics	twist.linear.x = 0.5*(u1+u2)	twist.angular.z = float(u1-u2)/l	#dead-reckon for some time	while(rospy.Time().now().secs - now < time and not rospy.is_shutdown()):		print("publishing ", str(twist.linear.x), " ", str(twist.angular.z))		pub.publish(twist)	#stop	twist.linear.x = 0	twist.angular.z = 0	pub.publish(twist)#This function accepts a speed and a distance for the robot to move in a straight linedef driveStraight(speed, distance):	global odom_list	global pub	# get most recent odom data	odom_list.waitForTransform("/odom","/base_footprint",rospy.Time(0),rospy.Duration(1, 0))	position, quaternion = odom_list.lookupTransform("/odom", "/base_footprint", rospy.Time(0))	# transform quat to euler	euler = tf.transformations.euler_from_quaternion(quaternion)	print("Pos ",str(position[0])," ",str(position[1])," ",str(position[2]),"Euler ",str(euler[0])," ",str(euler[1])," ",str(euler[2]) )	c_pos = position #c_pos is current position	start_pos = c_pos	twist = Twist()	#ramp velocity constants	pct_d = 0.1 #ratio of time accelerating to traveling	steps = 4	c_step = 1 #current step in accel func	#speed passed into twist msg	set_s = speed*(1.0/float(steps))	# block while trying to achieve distance	while(math.sqrt(float(c_pos[0])*c_pos[0] + float(c_pos[1])*c_pos[1]) - math.sqrt(float(start_pos[0])*start_pos[0] + float(start_pos[1])*start_pos[1])  < float(distance*.95) ):		my_dist = abs(math.sqrt(float(c_pos[0])*c_pos[0] + float(c_pos[1])*c_pos[1]) - math.sqrt(float(start_pos[0])*start_pos[0] + float(start_pos[1])*start_pos[1]) )		# check for velocity ramp at a given rate		b1 = (my_dist > distance*pct_d*1.0/float(steps) )		b2 = (my_dist > distance*(1.0-pct_d) )		if( b1 and not b2 ):			# velocity ramp based on distance			if(my_dist > distance*pct_d*float(c_step)/steps):				if(c_step < steps):					c_step += 1		# velocity ramp		if(b2):			if(my_dist > (distance*(1.0-pct_d)+ distance*pct_d*float((5.0-c_step))/steps) ):				if(c_step > 1):					c_step -= 1		set_s = speed*(float(float(c_step)/steps)) # set new speed		#update current position data		odom_list.waitForTransform("/odom","/base_footprint",rospy.Time(0),rospy.Duration(1, 0))		position, quaternion = odom_list.lookupTransform("/odom", "/base_footprint", rospy.Time(0))		c_pos = position		#update twist and publish		print(str()+' '+str(float(c_step)/steps))		print('Speed '+ str(set_s))		twist.linear.x = set_s		twist.angular.z = 0		pub.publish(twist)		rospy.sleep(rospy.Duration(0.1, 0))	#stop	twist.linear.x = 0	twist.angular.z = 0	pub.publish(twist)	return#Accepts an angle and makes the robot rotate around it.def rotate(angle):	global odom_list	global pub	# get odom data	odom_list.waitForTransform("/odom","/base_footprint",rospy.Time(0),rospy.Duration(1, 0))	position, quaternion = odom_list.lookupTransform("/odom", "/base_footprint", rospy.Time(0))	# transform quat to euler	euler = tf.transformations.euler_from_quaternion(quaternion)	c_pos = euler #c_pos is current position	start_pos = euler	twist = Twist()	#ramp velocity constants	pct_d = 0.1 #ratio of time accelerating to traveling	steps = 3	l = 0.23	c_step = 1	speed = 1	set_s = speed*(1.0/float(steps))	# block while trying to achieve distance	while(abs(float(c_pos[2]) - start_pos[2])  < abs(float(angle*.999)) ):		my_dist = abs(float(c_pos[2])-start_pos[2] )		#print'Angle '+ str(angle)		print str(c_pos[2])+'-'+str(start_pos[2])+'='+str(my_dist)		# check for velocity ramp at a given rate		b1 = (my_dist > my_dist*pct_d*1.0/float(steps) )		b2 = (my_dist > my_dist*(1.0-pct_d) )		#print(str(b1)+' '+str(b2))		if( b1 and not b2 ):			# velocity ramp based on distance			if(my_dist > my_dist*pct_d*float(c_step)/steps):				if(c_step < steps):					c_step += 1		# velocity de-ramp		if(b2):			if(my_dist > (my_dist*(1.0-pct_d)+ my_dist*pct_d*float((5.0-c_step))/steps) ):				if(c_step > 1):					c_step -= 1		set_s = speed*(float(float(c_step)/steps)) # set new speed		#update current position data		odom_list.waitForTransform("/odom","/base_footprint",rospy.Time(0),rospy.Duration(1, 0))		position, quaternion = odom_list.lookupTransform("/odom", "/base_footprint", rospy.Time(0))		c_pos = tf.transformations.euler_from_quaternion(quaternion)		#update twist and publish		twist.linear.x = 0		if(angle < 0):			set_s = -set_s		twist.angular.z = set_s		pub.publish(twist)	#stop	twist.linear.x = 0	twist.angular.z = 0	pub.publish(twist)#This function works the same as rotate how ever it does not publish linear velocities.def driveArc(radius, speed, angle):	pass  # Delete this 'pass' once implemented#Bumper Event Callback functiondef readBumper(msg):	if (msg.state == 1):		print'Bumper Hit'		# exec traj		executeTrajectory()	pass# (Optional) If you need something to happen repeatedly at a fixed interval, write the code here.# Start the timer with the following line of code:#   rospy.Timer(rospy.Duration(.01), timerCallback)def timerCallback(event):	global pose	odom_list.waitForTransform("/map","/base_footprint",rospy.Time(0),rospy.Duration(1, 0))	c_p, c_q = odom_list.lookupTransform("/map", "/base_footprint", rospy.Time(0))	pose.position.x = c_p[0]	pose.position.y = c_p[1]	q = [c_q[0],c_q[1],c_q[2],c_q[3]]	rol, pit, yaw = euler_from_quaternion(q)	pose.orientation.z = yaw	pass # Delete this 'pass' once implemented# This is the program's main functionif __name__ == '__main__':	# Change this node name to include your username	rospy.init_node('Lab_2_node_kpuczydlowski')	# These are global variables. Write "global <variable_name>" in any other function	#  to gain access to these global variables	global pub	global pose	global odom_tf	global odom_list	pose = Pose()	# Replace the elipses '...' in the following lines to set up the publishers and subscribers the lab requires	pub = rospy.Publisher('/cmd_vel_mux/input/teleop', Twist,queue_size =2) # Publisher for commanding robot motion	bumper_sub = rospy.Subscriber('/mobile_base/events/bumper', BumperEvent, readBumper, queue_size=2) # Callback function to handle bumper events	goal_sub = rospy.Subscriber('/move_base_simple/goal2',PoseStamped, navToPose, queue_size =1 )	# Use this object to get the robot's Odometry	odom_list = tf.TransformListener()	rospy.sleep(rospy.Duration(1, 0))	print "Starting Lab 2"	#make the robot keep doing something...	rospy.Timer(rospy.Duration(0.01), timerCallback)	# Make the robot do stuff...	#wait for some time for /move_base_simple/goal2 msg	rospy.sleep(rospy.Duration(100000000,0))	print "Lab 2 complete!"