#!/usr/bin/env pythonimport rospy, tfimport mathfrom std_msgs.msg import Stringfrom geometry_msgs.msg import Twistfrom kobuki_msgs.msg import BumperEventfrom nav_msgs.msg import Odometryfrom geometry_msgs.msg import PoseStampedfrom tf.transformations import euler_from_quaternion# Add additional imports for each of the message types used#drive to a goal subscribed as /move_base_simple/goaldef navToPose(goal):		print "spin!"	print "move!"	print "spin!"	print "done"	pass#This function sequentially calls methods to perform a trajectory.def executeTrajectory():		driveStraight(.25,.4)	print '1'	rotate(math.radians(90))	print '2'	driveStraight(.25,.25)	print '3'	rotate(-math.radians(135))#This function accepts two wheel velocities and a time interval.# assume u1 is left, u2 is right wheelsdef spinWheels(u1, u2, time):	global pub	now = rospy.Time().now().secs	twist = Twist()	l = .23	twist.linear.x = 0.5*(u1+u2)	twist.angular.z = float(u1-u2)/l	# print(str(rospy.get_time())," ",str(rospy.get_time() - now.secs)," ", str(ti))	# rate = rospy.Rate(10)	while(rospy.Time().now().secs - now < time and not rospy.is_shutdown()):		print rospy.Time().now().secs - now		print("publishing ", str(twist.linear.x), " ", str(twist.angular.z))		pub.publish(twist)				twist.linear.x = 0	twist.angular.z = 0	pub.publish(twist)#This function accepts a speed and a distance for the robot to move in a straight linedef driveStraight(speed, distance):	global odom_list	global pub	# get most recent odom data	odom_list.waitForTransform("/odom","/base_footprint",rospy.Time(0),rospy.Duration(1, 0))	position, quaternion = odom_list.lookupTransform("/odom", "/base_footprint", rospy.Time(0))	# transform quat to euler	euler = tf.transformations.euler_from_quaternion(quaternion)	print("Pos ",str(position[0])," ",str(position[1])," ",str(position[2]),"Euler ",str(euler[0])," ",str(euler[1])," ",str(euler[2]) )	c_pos = position #c_pos is current position	start_pos = c_pos	twist = Twist()	#ramp velocity constants	pct_d = 0.1 #ratio of time accelerating to traveling	steps = 4	c_step = 1	rampD = float(distance)*pct_d #time spend accelerating based on estimated travel time	set_s = speed*(1.0/float(steps))		# block while trying to achieve distance	while(math.sqrt(float(c_pos[0])*c_pos[0] + float(c_pos[1])*c_pos[1]) - math.sqrt(float(start_pos[0])*start_pos[0] + float(start_pos[1])*start_pos[1])  < float(distance*.925) ):		my_dist = abs(math.sqrt(float(c_pos[0])*c_pos[0] + float(c_pos[1])*c_pos[1]) - math.sqrt(float(start_pos[0])*start_pos[0] + float(start_pos[1])*start_pos[1]) )		#print str(c_pos[0])+' '+str(c_pos[1])+' '+str(my_dist)		# check for velocity ramp at a given rate		b1 = (my_dist > distance*pct_d*1.0/float(steps) )		b2 = (my_dist > distance*(1.0-pct_d) )		#print(str(b1)+' '+str(b2))		if( b1 and not b2 ):			# velocity ramp based on distance			if(my_dist > distance*pct_d*float(c_step)/steps):				if(c_step < steps):											c_step += 1		# velocity ramp 		if(b2):			if(my_dist > (distance*(1.0-pct_d)+ distance*pct_d*float((5.0-c_step))/steps) ):				if(c_step > 0):										c_step -= 1		set_s = speed*(float(float(c_step)/steps)) # set new speed		#update current position data		odom_list.waitForTransform("/odom","/base_footprint",rospy.Time(0),rospy.Duration(1, 0))		position, quaternion = odom_list.lookupTransform("/odom", "/base_footprint", rospy.Time(0))		c_pos = position		#update twist and publish		#print(str()+' '+str(float(c_step)/steps)) 			#print('Speed '+ str(set_s))		twist.linear.x = set_s		twist.angular.z = 0		pub.publish(twist)	twist.linear.x = 0	twist.angular.z = 0	pub.publish(twist)	return#Accepts an angle and makes the robot rotate around it.def rotate(angle):	global odom_list	global pub	# get most recent odom data	odom_list.waitForTransform("/odom","/base_footprint",rospy.Time(0),rospy.Duration(1, 0))	position, quaternion = odom_list.lookupTransform("/odom", "/base_footprint", rospy.Time(0))	# transform quat to euler	euler = tf.transformations.euler_from_quaternion(quaternion)	print("Pos ",str(position[0])," ",str(position[1])," ",str(position[2]),"Euler ",str(euler[0])," ",str(euler[1])," ",str(euler[2]) )	c_pos = euler #c_pos is current position	start_pos = euler	twist = Twist()	#ramp velocity constants	pct_d = 0.7 #ratio of time accelerating to traveling	steps = 1	l = 0.23	c_step = 1	speed = 1.1		rampD = float(angle)*pct_d #time spend accelerating based on estimated travel time	set_s = speed*(1.0/float(steps))		# block while trying to achieve distance	while(abs(float(c_pos[2]) - float(start_pos[2]) ) < float(abs(angle)) ):		my_dist = abs(float(c_pos[2]) - float(start_pos[2]) )		#print str(c_pos[2])+'-'+str(start_pos[2])+'='+str(my_dist)		# check for velocity ramp at a given rate		b1 = (my_dist > abs(angle)*pct_d*1.0/float(steps) )		b2 = (my_dist > abs(angle)*(1.0-pct_d) )		#print(str(b1)+' '+str(b2))		if( b1 and not b2 ):			# velocity ramp based on distance			if(my_dist > angle*pct_d*float(c_step)/steps):				if(c_step < steps):											c_step += 1		# velocity ramp 		if(b2):			if(my_dist > (angle*(1.0-pct_d)+ angle*pct_d*float((5.0-c_step))/steps) ):				if(c_step > 0):										c_step -= 1		set_s = speed*(float(float(c_step)/steps)) # set new speed		#update current position data		odom_list.waitForTransform("/odom","/base_footprint",rospy.Time(0),rospy.Duration(1, 0))		position, quaternion = odom_list.lookupTransform("/odom", "/base_footprint", rospy.Time(0))		c_pos = tf.transformations.euler_from_quaternion(quaternion)		#update twist and publish		#print(str()+' '+str(float(c_step)/steps)) 		#if(set_s < 0):			if(angle < 0):			set_s = -1*set_s		print('Speed '+ str(set_s))		twist.linear.x = 0		twist.angular.z = set_s		pub.publish(twist)	twist.linear.x = 0	twist.angular.z = 0	pub.publish(twist)def printPos():	global odom_list	global pub	while (True):		t = 0		if odom_list.frameExists("/base_link") and tf.frameExists("/map"):			t = odom_list.getLatestCommonTime("/base_link", "/map")			position, quaternion = odom_list.lookupTransform("/base_link", "/map", t)		euler = tf.transformations.euler_from_quaternion(quaternion)		print("Pos ",str(position[0])," ",str(position[1])," ",str(position[2]),"Euler ",str(euler[0])," ",str(euler[1])," ",str(euler[2]),"T ",str(t))		now = rospy.get_time()		while(rospy.get_time().sec - now.sec < 1):			t = 1#This function works the same as rotate how ever it does not publish linear velocities.def driveArc(radius, speed, angle):	pass  # Delete this 'pass' once implemented#Bumper Event Callback functiondef readBumper(msg):	if (msg.state == 1):		# What should happen when the bumper is pressed?		print 'Bumper Pressed'		executeTrajectory()	pass# (Optional) If you need something to happen repeatedly at a fixed interval, write the code here.# Start the timer with the following line of code:#   rospy.Timer(rospy.Duration(.01), timerCallback)def timerCallback(event):	global pose	pose = Pose()    (position, orientation) = odom_list.lookupTransform('/move_base_simple/goal','/base_footprint', rospy.Time(0)) #finds the position and oriention of two objects relative to each other (hint: this returns arrays, while Pose uses lists)	pass # Delete this 'pass' once implemented# This is the program's main functionif __name__ == '__main__':	# Change this node name to include your username	rospy.init_node('Lab_2_node_kpuczydlowski')	# These are global variables. Write "global <variable_name>" in any other function	#  to gain access to these global variables	global pub	global pose	global odom_tf	global odom_list	# Replace the elipses '...' in the following lines to set up the publishers and subscribers the lab requires	pub = rospy.Publisher('/cmd_vel_mux/input/teleop', Twist,queue_size =2) # Publisher for commanding robot motion	bumper_sub = rospy.Subscriber('/mobile_base/events/bumper', BumperEvent, readBumper, queue_size=1) # Callback function to handle bumper events			# Use this object to get the robot's Odometry	odom_list = tf.TransformListener()	rospy.sleep(rospy.Duration(1, 0))	print "Starting Lab 2"	#make the robot keep doing something...	rospy.Timer(rospy.Duration(1), timerCallback)		# Make the robot do stuff...	#rotate(-math.radians(135))	#driveStraight(0.2,1)	rospy.sleep(rospy.Duration(100000, 0))	#spinWheels(3,3,10)	#driveStraight(0.5,1)	#rotate(0.2)	print "Lab 2 complete!"